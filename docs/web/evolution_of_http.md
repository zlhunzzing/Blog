# HTTP의 진화

## World Wide Web의 발명

1989년 팀 버너스 리가 하이퍼텍스트 시스템을 제안했다. HTML, HTTP, 최초의 웹 브라우저, htttpd의 초기 버전인 서버 이 4가지는 1990년 말에 완성되었다. 1991년 8월 6일 팀 버너스 리는 뉴스 그룹(newsgroup)에 이것을 공개했다.

## HTTP/0.9 - 한 줄 프로토콜

HTTP의 초기 버전에는 버전 번호가 없었다. 이후 버전과 구별하기 위해 0.9로 불렀다. 요청은 한 줄로 구성되었으며 유일한 방법으로 GET 리소스의 경로가 따라왔다. HTTP 헤더가 없었고 이는 HTML 파일만 전송할 수 있음을 의미했다.

## HTTP/1.0 - 확장성 구축

상호 운용성 문제를 해결하기 위한 노력의 하나로 일반적인 관행을 설명하는 정보 문서가 1996년 11월에 게시되었다. 이것은 RFC 1945로 알려졌으며 HTTP/1.0을 정의했다.

- 각 요청 내에서 버전 정보가 전송되었다.
- 응답 시작 시 상태 코드 줄도 전송되었다. 브라우저 자체가 요청의 성공 또는 실패를 인식하고 그에 따라 동작을 조정할 수 있다. (로컬 캐시 업데이트 등)
- HTTP 헤더 개념이 도입되었다. 메타데이터를 전송할 수 있었고 프로토콜은 매우 유연하고 확장 가능해졌다.
- 헤더로 인해 일반 HTML 파일 이외의 문서를 전송할 수 있다. (Content-Type)

## HTTP/1.1 - 표준화된 프로토콜

적절한 표준화가 진행되었다. HTTP의 첫 표준화 버전인 HTTP/1.1은 HTTP/1.0 이후 불과 몇 달 후인 1997년 초에 게시되었다.

- 연결을 재사용할 수 있어 시간이 절약되었다. 단일 원본 문서에 포함된 리소스를 표시하기 위해 여러 번 열 필요가 없다. (연속적인 요청 사이에 커넥션을 유지하여 새 커넥션을 여는 데 필요한 시간을 줄인다.)
- 파이프라이닝이 추가되었다. 첫 번째 요청에 대한 응답이 완전히 전송되기 전에 두 번째 요청을 보낼 수 있다. 이에 따라 통신 대기 시간이 단축되었다.
- 청크 응답(Chunked response)도 지원되었다.
- 추가 캐시 제어 메커니즘이 도입되었다. (Cache-Control)
- 언어, 인코딩 및 타입을 포함한 콘텐츠 협상(Content negotiation)이 도입되었다. 클라이언트와 서버는 교환할 콘텐츠에 대해 동의할 수 있다. (콘텐츠 협상은 리소스가 호출될 때 특정 표현이 선택되는 방식을 결정한다.)
- Host 헤더 덕분에 동일한 IP 주소에서 다른 도메인을 호스트할 수 있는 기능을 통해 서버 연결을 허용했다.

## 15년 이상의 확장

HTTP의 확장성 덕분에 새로운 헤더와 메서드를 쉽게 만들 수 있었다. HTTP/1.1 프로토콜은 개정판을 거쳐 개선되었지만 15년 이상 동안 매우 안정적이었다.

### 보안 전송을 위한 HTTP 사용 (HTTPS)

1994년 말 TCP/IP 스택을 통해 HTTP를 보내는 대신 컴퓨터 서비스 회사인 넷스케이프(Netscape Communications)는 그 위에 SSL이라는 추가 암호화 전송 계층을 만들었다. SSL 1.0은 대중에게 공개되지 않았지만 SSL 2.0과 SSL 3.0은 전자상거래 웹사이트를 만들 수 있게 해주었다. SSL은 결국 표준화되어 TLS가 되었다. HTTP를 통해 구축된 애플리케이션이 더욱 강력해지고 주소록, 이메일 및 사용자 위치와 같은 개인 정보에 대한 액세스가 필요해짐에 따라 전자상거래 사용 사례 외부에서 TLS가 필요하게 되었다. 

### 복잡한 애플리케이션을 위한 HTTP 사용

팀 버너스 리는 원래 HTTP를 읽기 전용 매체로 생각하지 않았다. 그는 사람들이 원격으로 문서를 추가하고 이동할 수 있는 일종의 분산 파일 시스템인 웹을 만들고 싶었다. 1996년경에 저작이 가능하도록 HTTP가 확장되었고 WebDAV라는 표준이 만들어졌으나 서버에서 구현되었을 때만 사용할 수 있었다.

2000년에 HTTP 사용을 위한 새로운 패턴인 REST(representational state transfer)가 설계되었다. API는 새로운 HTTP 메서드를 기반으로 하지 않고 대신 기본 HTTP/1.1 메서드를 사용하여 특정 URI에 대한 액세스에 의존했다. 이를 통해 웹 애플리케이션은 API가 브라우저나 서버를 업데이트하지 않고도 데이터를 검색하고 수정할 수 있다. REST 모델의 단점은 각 웹사이트가 자체 비표준 RESTful API를 정의하고 이를 완전히 제어할 수 있다는 것이다.

2005년부터 웹 페이지에서 더 많은 API를 사용할 수 있게 되었다. 이러한 API 중 일부는 특정 목적을 위해 HTTP 프로토콜에 대한 확장을 생성합니다.
- Server-sent events - 서버가 가끔 메시지를 브라우저에 푸시할 수 있다.
- 기존 HTTP 연결을 업그레이드하여 설정할 수 있는 새로운 프로토콜인 WebSocket.

### 웹의 보안 모델 완화

HTTP는 동일 출처 정책으로 알려진 웹 보안 모델과 독립적이다. 현재의 웹 보안 모델은 HTTP가 생성된 이후에 개발되었다. 수년에 걸쳐 특정 제약 조건 하에서 이 정책의 일부 제한을 해제하는 것이 유용하다는 것이 입증되었다. 서버는 새로운 HTTP 헤더 집합을 사용하여 이러한 제한을 해제할 양과 시기를 클라이언트에 전송했다. 이들은 CORS(Cross-Origin Resource Sharing) 및 CSP(Content Security Policy)와 같은 사양에서 정의되었다.

이러한 대규모 확장 외에도 많은 다른 헤더가 추가되었으며 때로는 실험적으로 추가되었다. 주목할 만한 헤더로는 ```Do Not Track(DNT)``` , ```X-Frame-Options``` , ```Upgrade-Insecure-Requests``` 등이며 더 많은 헤더가 있다.

## HTTP/2 - 성능 향상을 위한 프로토콜

수년에 걸쳐 웹 페이지는 더욱 복잡해졌다. 그들 중 일부는 그 자체로 응용 프로그램이었다. 더 많은 시각적 미디어가 표시되고 상호작용을 추가하는 스크립트의 양과 크기도 증가했다. 훨씬 더 많은 HTTP 요청을 통해 훨씬 더 많은 데이터가 전송되었고 이에 따라 HTTP/1.1 연결에 더 많은 복잡성과 오버헤드가 발생했다. 이를 설명하기 위해 구글은 2010년대 초반에 실험적인 프로토콜 SPDY를 구현했다. 클라이언트와 서버 간에 데이터를 교환하는 이 대체 방법은 브라우저와 서버 모두에서 작업하는 개발자의 관심을 모았다. SPDY는 응답성 향상을 정의하고 중복 데이터 전송 문제를 해결하여 HTTP/2 프로토콜의 기반이 되었다.

HTTP/2 프로토콜은 몇 가지 면에서 HTTP/1.1과 다르다.

- *텍스트 프로토콜이 아닌 바이너리 프로토콜이다. 수동으로 읽고 만들 수 없다. 이러한 장애물에도 불구하고 개선된 최적화 기술을 구현할 수 있다.
- 다중화 프로토콜이다. HTTP/1.x 프로토콜의 제약 조건을 제거하여 동일한 연결을 통해 병렬 요청을 만들 수 있다.
- 헤더를 압축합니다. 이는 요청 세트 간에 유사한 경우가 많기 때문에 전송된 데이터의 중복 및 오버헤드가 제거된다.
- 이를 통해 서버는 *서버 푸시(Server Push)라는 메커니즘을 통해 클라이언트 캐시에 데이터를 채울 수 있다.

2015년 5월에 공식적으로 표준화된 HTTP/2 사용은 2022년 1월에 모든 웹사이트의 46.9%에서 정점을 찍었다. 트래픽이 많은 웹사이트는 데이터 전송 오버헤드와 후속 예산을 절약하기 위한 노력으로 가장 빠른 채택률을 보였다.

HTTP/2가 웹사이트와 애플리케이션을 변경할 필요가 없었기 때문에 이렇게 빠르게 채택되었을 가능성이 크다. 이를 사용하려면 최신 브라우저와 통신하는 최신 서버만 있으면 된다. 채택을 촉발하는 데는 제한된 그룹 세트(limited set of groups)만 필요했고 레거시 브라우저와 서버 버전이 갱신되면서 웹 개발자가 큰 노력을 기울이지 않아도 자연스럽게 사용량이 증가했다.

### *텍스트 프로토콜과 바이너리 프로토콜
텍스트 프로토콜은 사람이 읽을 수 있는 형식으로, 종종 텍스트로 나타내어진다. 텍스트 기반 프로토콜은 사람의 해석에 최적화되어 있으므로 디버깅 및 초기 프로토콜 개발 설계 단계와 같이 프로토콜 내용을 사람이 검사해야 할 때마다 적합하다.

바이너리 프로토콜은 ASCII 인코딩에서 사람이 읽을 수 있는 문자에 해당하는 값만 사용하는 텍스트 기반 프로토콜과 달리 byte의 모든 값을 사용한다. 바이너리 프로토콜은 사람이 아닌 기계가 읽을 수 있도록 만들어졌다. 전송 및 해석 속도로 변환되는 간결함의 이점이 있다.

### *HTTP/2 Server Push

HTTP/2 서버 푸시는 HTTP/2 HTTP/3 네트워크 프로토콜의 선택적 기능으로, 클라이언트가 리소스를 요청하기 전에 서버가 클라이언트에 리소스를 보낼 수 있다. 서버 푸시는 클라이언트가 리소스가 필요하다는 것을 알기도 전에 리소스를 선제적으로 로드하여 대기 시간을 줄이는 것을 목표로 하는 성능 기술이다. 서버는 index.html을 요청하는 헤더 프레임(HEADERS frame)을 수신하고 styles.css 및 script.js의 필요성을 예측할 수있다.

## HTTP/2 이후 진화

HTTP의 확장성은 여전히 새로운 기능을 추가하는 데 사용되고 있다. 특히 2016년에 등장한 HTTP 프로토콜의 새로운 확장을 인용할 수 있다.

- ```*Alt-Svc``` 에 대한 지원으로 주어진 리소스의 식별 및 위치의 허용된 분리를 지원한다. 이것은 더 스마트한 CDN 캐싱 메커니즘을 의미했다.
- *클라이언트 힌트의 도입으로 브라우저 또는 클라이언트는 요구 사항 및 하드웨어 제약 조건에 대한 정보를 서버에 사전에 전달할 수 있었다.
- ```Cookie``` 헤더에 보안 관련 접두사를 도입하여 보안 쿠키를 변경할 수 없도록 했다.

### *Alt-svc 헤더

Alt-svc 헤더를 사용하면 향후 요청할 때 서버가 다른 네트워크 위치("대체 서비스")를 해당 출처에 대해 권한이 있는 것으로 취급할 수 있음을 나타낼 수 있다. 이렇게 하면 진행 중인 요청에 영향을 주지 않고 새 프로토콜 버전을 알릴 수 있으며 서버가 트래픽을 관리하는 데 도움이 될 수도 있다.

### *Client hints(클라이언트 힌트)

Client Hints는 클라이언트 장치 및 에이전트별 기본 설정 목록을 확인할 수 있도록 사전 컨텐츠 체크를 위한 HTTP request header이다. Client Hints를 사용하면 이미지 DPR 해상도의 자동 조절과 최적화된 assets을 자동으로 적용할 수 있다.

일반적으로, Client Hints header를 가지고 개발자 또는 어플리케이션은 브라우저에 장치 픽셀 비율, 뷰포트 너비 및 디스플레이 너비와 같은 서버 자체 정보를 제공하도록 할 수 있다. 그러면 클라이언트는 서버에 클라이언트 환경에 대한 정보를 제공할 수 있고, 서버는 해당 정보를 기반으로 전송할 리소스를 결정할 수도 있다.

## HTTP/3 QUIC를 통한 HTTP

HTTP의 다음 주요 버전인 HTTP/3은 이전 버전의 HTTP와 동일한 의미를 갖지만 전송 계층 부분에 대해 TCP 대신 QUIC를 사용한다. 2022년 10월까지 모든 웹사이트의 26%가 HTTP/3을 사용하고 있었다.

QUIC은 HTTP 연결에 대해 훨씬 낮은 대기 시간을 제공하도록 설계되었다. HTTP/2와 마찬가지로 다중화된 프로토콜이지만 HTTP/2는 단일 TCP 연결을 통해 실행되므로 TCP 계층에서 처리되는 패킷 손실 감지 및 재전송은 모든 스트림을 차단할 수 있다. QUIC은 UDP를 통해 여러 스트림을 실행하고 각 스트림에 대해 독립적으로 패킷 손실 감지 및 재전송을 구현하므로 오류가 발생하면 해당 패킷에 데이터가 있는 스트림만 차단된다.

RFC 9114에 정의된 HTTP/3은 Chromium(및 Chrome 및 Edge와 같은 변형) 및 Firefox를 포함한 대부분 주요 브라우저에서 지원된다.

### - 참고문서

"Evolution of HTTP" mdn web docs, last modified: 2023년 4월 11일, https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP, accessed: 2023년 5월 16일

"HTTP/1.x의 커넥션 관리" mdn web docs, last modified: 2023년 1월 7일, https://developer.mozilla.org/ko/docs/Web/HTTP/Connection_management_in_HTTP_1.x, accessed: 2023년 5월 16일

"Content_negotiation" mdn web docs, last modified: 2023년 4월 11일, https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation, accessed: 2023년 5월 16일

"HTTP Caching" IETF Datatracker, https://httpwg.org/specs/rfc9111.html#rfc.section.5.2, accessed: 2023년 5월 16일

"HTTPS" wikipedia, last modified: 2023년 5월 7일, https://en.wikipedia.org/wiki/HTTPS, accessed: 2023년 5월 16일

"Communication protocol" wikipedia, last modified: 2023년 4월 11일, https://en.wikipedia.org/wiki/Communication_protocol, accessed: 2023년 5월 16일

"Alt-Svc" mdn web docs, last modified: 2023년 4월 11일, https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Alt-Svc, accessed: 2023년 5월 16일

"Client hints(클라이언트 힌트)" mdn web docs, last modified: 2023년 1월 7일, https://developer.mozilla.org/ko/docs/Web/HTTP/Client_hints, accessed: 2023년 5월 16일

<Comment />